<?php
/**
 * @file
 * Code for the Vim.org Project feature.
 */

include_once 'vimorg_project.features.inc';

/**
 * Implements hook_form_alter().
 */
function vimorg_project_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'project_node_form') {

    // We'll fill this in the next time they push code to their Github repo.
    $form['body']['#access'] = FALSE;

    // We're autogenerating the project key when the node is saved. It can
    // be regenerated by changing the "created" column for that node and
    // then resaving the node.
    $form['field_project_key']['#access'] = FALSE;

    // Make sure our key generation function fires.
    $form['actions']['submit']['#validate'][] = 'vimorg_project_generate_key';
  }
}

/**
 * Form submission callback for project_node_form.
 *
 * Set the project key field, which will be used for authenticating
 * commit information passed from Github (to prevent unauthorized users
 * from creating commit information in this project)
 */
function vimorg_project_generate_key($form, &$form_state) {
  $node = $form['#node'];
  $key_string = $node->nid . $node->created . variable_get('vimorg_project_key_salt', 'vimorg');
  $form_state['values']['field_project_key']['und'][0]['value'] = md5($key_string);
}

/**
 * Implements hook_menu().
 */
function vimorg_project_menu() {
  $items = array();

  $items['github/%projectkey'] = array(
    'title' => 'Github Web Hook URL',
    'access callback' => TRUE,
    'page callback' => 'vimorg_project_github_post',
    'page arguments' => array(1),
    'type' => MENU_CALLBACK,
  );

  $items['github'] = $items['github/%projectkey'];

  return $items;
}

/**
 * Menu callback for handling Github post requests.
 */
function vimorg_project_github_post($project_key = NULL) {
  // Ensure that a project key is supplied.
  if ($project_key == NULL) {
    print t('You must supply a project key');
    exit();
  }

  // Lookup the node by the supplied project key.
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'project')
    ->fieldCondition('field_project_key', 'value', $project_key)
    ->execute();

  // Get the Node IDs returned by the EntityFieldQuery;
  $nids = array_keys($result['node']);

  // Load those nodes (there should only be one)
  $node = entity_load('node', $nids);

  // Simplify the contents of $node (we are assuming that only one node was
  // returned by the EntityFieldQuery.
  $node = $node[$nids[0]];

  // Get the Github data as a multidimensional array.
  $github_information = $_POST['payload'];
  $github_information = json_decode($github_information);

  // Invoke hook_vimorg_github_response().
  module_invoke_all('vimorg_github_response', $github_information, $node);

  exit();
}

/**
 * Implements hook_vimorg_github_response().
 *
 * Does the following:
 *   * Updates the node body using any available README file
 *   * @todo:Updates any project download links
 */
function vimorg_project_vimorg_github_response($github_information, $node) {
  // Update the node body.
  $repository = $github_information['repository'];
  $base_repo_url = $repository['url'];
  $base_repo_url = str_replace('github.com', 'raw.github.com', $base_repo_url);

  // Build a list of potential README URLs.
  $urls = array(
    $base_repo_url . '/master/README',
    $base_repo_url . '/master/README.mkdown',
    $base_repo_url . '/master/README.markdown',
  );

  // Loop through the URLs and find the first one that gives us a
  // 200 response code.
  $readme_url = '';
  foreach ($urls as $url) {
    $response_headers = get_headers($url, 1);
    if ($response_headers[0] == 'HTTP/1.1 200 OK') {
      $readme_url = $url;
      break;
    }
  }

  if ($readme_url != '') {
    $node->body['und'][0]['value'] = file_get_contents($readme_url);
    node_save($node);
  }
  else {
    // Fallback to using the (very) short Github repo description.
    $node->body['und'][0]['value'] = $repository['description'];
    node_save($node);
  }

  // @todo: Update any download links.
}
